//«адание графа списком рЄбер
const ll maxv=100,maxe=100000;//максимум вершин и рЄбер соответственно
//¬ этих массивах хранитс€ следующа€ информаци€:
//first[i] - хранитс€ номер последнего ребра, которое выходит из вершины i
//ef[i] - хранит номер вершины, из которой выходит ребро с номером i
//es[i] - хранит номер вершины, в которую входит ребро с номером i
//ev[i] - хранит вес с номером i
//next[i] - хранит номер предыдущего ребра, которое выходит из той же вершины, что и ребро под номером i
//c - указатель и счЄтчик кол-ва рЄбер
ll first[maxv],es[maxe],ef[maxe],ev[maxe],next[maxe],c=0;

typedef long long ll;

//‘ункци€ добавлени€ ребра работает следующим образом: на вход мы получаем номер вершины начала ребра, номер вершины конца ребра, и вес ребра.
//“еперь что мы делаем: мы дл€ ребра с номером C ставим предка из массива first[v1], если предок равен нулю, значит, что это крайнее ребро.
//«атем, мы ставим в массиве first[v1] что ребро под номером — есть последнее ребро, выход€щее из этой вершины.
//Ќу а дальше мы записываем в ef[c], что началом ребра — €в€летс€ вершина v1, в es[c] - что его концом €вл€етс€ вершина v2,а в ev[c] - 
//что вес ребра — равен val.

//“акже нужно заметить, что дл€ добавлени€ двунаправленного ребра нужно 2 раза вызвать функцию init(): init(v1,v2,val) и init(v2,v1,val).
//» также встречаетс€ ещЄ 1 сособ задани€ списка рЄбер при помощи ещЄ одного массива last (такой способ также будет у мен€ встречатьс€).
//Ќо его использовать нецелесообразно: там просто вводитс€ ещЄ 1 лишний массив, который нужен только дл€ построени€ списка рЄбер.Ќо и без него можно построить.
//≈сли вы встретите такой способ, то без труда разберетесь - логика там почти така€ же, как и в этом способе.

void init(ll v1,ll v2,ll val)
{
	next[++c]=first[v1];first[v1]=c;
	ef[c]=v1;es[c]=v2;ev[c]=val;
}