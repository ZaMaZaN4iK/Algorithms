//Алгоритм Дейкстры для нахождения расстояния от 1 вершины до всех остальных за О(MlogN) с использованием структуры данных Куча
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>

using namespace std;
//устанавливаем максимум вершин и рёбер, и массивы для списка рёбер
const int maxe=100,maxv=100;
int ef[maxe],es[maxe],ev[maxe],next[maxe],first[maxv],c=0,i;
vector<long long> d(maxv+1,100000000),p(maxv+1);//массив расстояний и массив предков(для восстановления пути)
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;//это и есть наша куча,в ней мы будем хранить пары, в которой первое значение - вес,
//а 2-ое - это номер вершины

//Добавляем ребра

void add(int v1,int v2,int value)
{
    next[++c]=first[v1];first[v1]=c;
    ef[c]=v1;es[c]=v2;ev[c]=value;
}

//Инициализируем граф

void init()
{
    int x,y,z;
    for(i=0;i<5;++i)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
}

//Главная функция.Как это работает: в s мы пишем номер вершины, от которой хотим начать поиск.В массиве d у нас хранятся расстояния от вершины s до вершин под
//индексом i(Изначально они забиты бесконечностями для корректной работы алгоритма).ТО есть пара вглядит(0,i).
//В d[s] мы стаим 0,так как расстояние само в себя равно 0.И поместим в кучу пару
//(0,s).Будем считать,что каждая такая пара означает следующее:"Минимальное расстояние от вершины s до вершины i, где расстояние - это 1-ый элемент пары, а вершина i
// - 2-ой.И теперь до тех пор, пока куча не пуста, делаем следующее:извлекаем пару из кучи, удаляем её.И сразу же делаем проверку, которая очень сильно оптимизирует
//скорость алгоритма - если расстояние, которое мы извлекли из кучи до вершины i больше, чем расстояние до вершины i в массие d, то переходим на следующую итерацию
//алгоритма.Это такой способ подстраивания кучи под нужды Дейкстры - так как просто так удалять мы из кучине можем, то вот таким способом мы заведомо плохие варинаты
//которые в куче всё же лежат, отсекаем.Это работает, потому что именно в массие d у нас хранятся расстояния до вершин, а в куче у нас хранятся временные рабочие
//значения.Если же под это исключение не попали, то мы смотрим все рёбра, выходящие из вершины i(это та вершина, которую мы извлекли из кучи).
//И смотрим: если расстояние до вершины i(мы его тоже извлекли из кучи) + расстояние от i до 2-ого конца ребра строго меньше, чем значение в массиве d для 2-ого 
//конца ребра(а это расстояние есть расстояние от вершины s до конца текущего ребра), то мы записываем в ячейку d с номером 2-ого конца ребра значение
//расстояние до вершины i(мы его тоже извлекли из кучи) + расстояние от i до 2-ого конца ребра(а это есть просто вес ребра).И ложим пару с новым расстоянием до
//этой вершины и саму вершину в кучу.И также, если нам нужно не просто узнать минимальную стоимость пути, но и восстановить его, то в массив предков (p) в ячейку 
// с номером 2-ого конца ребра мы положим номер вершины, из которой мы улучшили до неё расстояние, а это есть номер i(в коде эот to).

//Впринципе это всё.В конце работы алгоритма в d[i] будут хранится минимальные расстояния от вершины s до вершины i.Хочется отметить, что алгоритм работает только
// для графов с положительным весом рёбер - для отрицательных его применять нельзя.Также если у нас в d[i] лежит бесконечность, то до этой вршины дойти нельзя.

//Функция восстановления пути пишется просто - стартуем от той вершины, до которой хоетли дойти.И так как у нас хранятся в массиве ссылки на вершину, из которой 
//мы пришли в неё, то переходим по ссылкам до тех пор, пока не дойдем до вершины s.А потом полученную последовательность переворачиваем, и получаем правильный путь.

void dist()
{
    int s=1;
    d[s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int to=q.top().second;int line=q.top().first;
        q.pop();
        if(line>d[to])  continue;
        for(int h=first[to];h;h=next[h])
            if(line+ev[h] < d[es[h]])
            {
                d[es[h]]=line+ev[h];
                p[es[h]]=to;
                q.push(make_pair(d[es[h]],es[h]));
            }
    }
}

//Тут просто инициализируем граф, затем пускаем Дейкстру, и выводим расстояние до 2 вершины

int main()
{
    init();
    dist();
    cout<<d[2]<<endl;
    system("pause");
    return 0;
}
