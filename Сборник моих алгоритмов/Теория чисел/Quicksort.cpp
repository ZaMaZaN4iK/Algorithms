//Хоть и улучшенная реализация этой сортировки есть в STL(там не совсем сортировка Хоара, там Introsort), но я всё же приведу описание работы этого алгоритма. Алгоритм имеет сложность O(NlogN) в среднем, но на специальных антитестах имеет O(N*N).
//Описание работы алгоритма: на вход поступает массив, и границы сортировки. Мы берём средний элемент. Он разбивает наш сортируемый отрезок на 2 части - левую и правую. Теперь в левой ищём линейно первый элемент, который строго больше среднего, а в правой элемент, который строго меньше среднего. После того как нашли, меняем их местами. Так продолжаем до тех пор, пока области поиска элементов не пересекутся. А в конце проверяем, добежали ли мы до границ сортируемого отрезка. Если да, то массив отсортирован, если же нет - то вызываем рекусрсивно нашу сортировку с меньшими отрезками.


void quicksort(vector<int> &arr,int l,int r)
{
    int i=l,j=r,mid=arr[l+((r-l)>>1)];
    while(i<=j)
    {
        while(arr[i] < mid) i++;
        while(arr[j] > mid) j--;
        if(i<=j)
        {
            swap(arr[i],arr[j]);
            i++;
            j--;
        }
    }
    if(i < r)
        quicksort(arr,i,r);
    if(l<j)
        quicksort(arr,l,j);
}
